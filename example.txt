Example 1:

Analyze the DataFrame `df` and classify each RFI into one of **five categories** based on its `RFI Description` and `Internal NYA Comments`:

Categories and Matching Keywords (case-insensitive):

1. **Structural Scope** — match any of: "structural", "concrete", "steel", "beam", "column", "load", "slab", "rebar", "footing", "shear", "seismic"
2. **Field Installation Issues** — match any of: "incorrect", "field condition", "existing", "as-built", "site issue", "fix", "field"
3. **Non-Structural Scope** — match any of: "light gauge", "architectural", "mep", "façade", "drywall", "partition", "shoring", "non-structural", "response per others", "no structural input"
4. **Proposed Design Changes** — match any of: "value engineering", "alternate design", "change request", "modify", "revised", "proposed"
5. **Other Out-of-Scope** — match any of: "outside scope", "not our scope", "unforeseen", "out-of-scope", "out of scope", "not structural"

**Classification Logic**:
- First perform a **case-insensitive keyword match** across both `RFI Description` and `Internal NYA Comments`.
- If a match is found, classify immediately into the corresponding category.
- If no keywords match, and the RFI appears potentially out-of-scope or ambiguous, use the `client` (a ChatOpenAI instance from `langchain_openai`) to classify it.
- The LLM should be used **only for unclassified cases**, with **at most 20 LLM calls per run** to avoid latency.
- If the classification returned by the LLM is not one of the five valid categories, skip the RFI.

**LLM Call Format** (only for unmatched rows):
- Use one `client.ainvoke()` call per RFI.
- Combine both fields as input and ask the model to return only the category name (verbatim).
- Example message format:
  - System: "You are an expert assistant classifying RFIs into exactly one of 5 categories."
  - User: "Classify the following RFI into one of: Structural Scope, Field Installation Issues, Non-Structural Scope, Proposed Design Changes, Other Out-of-Scope.\\n\\nRFI Description: ...\\nComments: ..."

**Output**:
- Create an Excel file named `classified_rfis.xlsx` with five sheets — one per category.
- Each sheet must contain the following columns: `RFI #`, `RFI Description`, `Internal NYA Comments`, `Business Days`.

**Technical Requirements**:
- Use only modern pandas (v2.3.0+) methods — avoid deprecated APIs.
- Use `.copy()` when modifying slices to avoid `SettingWithCopyWarning`.
- Use `.fillna("")` to handle missing values in the relevant columns.
- Use `asyncio.Semaphore` to limit concurrent LLM calls.
- Save the Excel file using `with ExcelWriter(...) as writer: ...`.

Execute the classification and write the final Excel output to disk.



Example 2:
Plot me number of RFIs I am receiving per month in a beautiful line plot. Keep the x axis clean. Also add a dashed line for the average.



Example 3:
I want to find extract location indicators from RFI 2595, based only on its RFI description
1. Use a language model (already available as langchain_openai.ChatOpenAI `client`) to extract keywords
2. The function must accept both `df` and `client` as arguments.
3. The function must print a list of location indicators.
4. DO NOT print any additional information.


Example 4:
I want to find RFIs in the same or nearby location as RFI 2595, based only on its description.
Use the language model (client) to:
1. Extract location keywords from RFI 2595 as a comma separated string.
2. Generate common variants (like “NE” for “North East”, or “L1” for “Level 1”).
3. Use Pydantic to validate the location keywords. This should be in the form of a list of strings. 
4. DO NOT generate any additional information.
5. Once the validated list is generated, print the list.
6. Give a detailed prompt to the LLM to enforce all the above steps. DO NOT deviate.


Then:
1. Use regex and fuzzy matching to check if any other RFI descriptions match these keywords or variants.
2. If matched, classify as "Related Location", otherwise "Unrelated".
3. Do not use the LLM for classification — only for keyword extraction.

Save the results to related_to_rfi_2595.xlsx with columns: RFI #, RFI Description, Classification.
All logic must stay inside one function: async def main(df, client)
Print only errors, use modern pandas, and end with: asyncio.run(main(df, client))



Example 5:
Create a line plot showing the following: number of outstanding RFIs, number of RFIs received  and RFIs responded to in each week. Create a beautiful plot with clean X axis. Make Responded  RFIs and number of RFIs received as vertical bars on the plot. Keep outstanding RFIs as line plot. Make the bar plots as separate 
bars. Donot overlap them. Keep the X axis organized and clean